/* 
Manage trading operations, including entry and exit signals, position sizing, and risk management.
Uses the Alpaca API to open and close based on the conditions generated by solar strategy, decided by solar sensor data.
After each trade, logs details to Google Sheets. 
*/

// Access the required modules to handle trading operations and logging
const { getTPandSL, getRiskProfile, getMaxHoldMinutes } = require('./solarStrategy'); // Import the solar strategy functions
const { logToSheet } = require('./logToSheets'); // Import the Google Sheet logging function 
const alpaca = require('./alpaca'); // Access the Alpaca API (for trading operations)

const TRADE_LOG_SHEET = 'Alpaca Trades'; // name of Google Sheet tab to log trades

// Define the TradeManager class to manage trading operations
// The constructor initializes the account balance and sets up arrays for open and closed trades
// The class also includes methods for evaluating trade entries, updating open trades, and closing trades

class TradeManager {
  constructor(accountBalance) {
    this.accountBalance = accountBalance; // an instance variable to store the account balance
    this.openTrades = []; // current open trades array
    this.closedTrades = []; // closed traded array 
    console.log(`üí∞ TradeManager initialized with account balance: $${this.accountBalance}`); 
  }

  // Check if the sensor data is valid
  isValidSensorData(lux, temp, humidity) {
    return (
      typeof lux === 'number' && lux >= -1 && // Lux values set to between -1 and 10,000
      typeof temp === 'number' && temp > -50 && temp < 150 &&
      typeof humidity === 'number' && humidity >= 0 && humidity <= 100
    );
  }

  // Evaluate trade entry based on sensor data and market conditions
  async evaluateTradeEntry(symbol, mood, lux, temp, humidity) {
    try {
      const { takeProfit, stopLoss } = getRiskProfile(lux); // TP & SL values based on lux imported from solarStrategy
      const maxHoldMinutes = getMaxHoldMinutes(humidity); // maximum holding time based on humidity imported from solarStrategy


      if (!symbol || typeof symbol !== 'string') {
        return { executed: false, reason: 'Invalid symbol provided' };
      } 

      if (!this.isValidSensorData(lux, temp, humidity)) {
        return { executed: false, reason: 'Invalid sensor data provided' };
      }

      // check if there is already an open position for the stock's symbol 
      const existingPosition = this.openTrades.find(trade => trade.symbol === symbol);
      if (existingPosition) {
        return { executed: false, reason: `Already have an open position in ${symbol}` };
      }

      const signal = await this.getEntrySignal(symbol); // get entry signal from Alpaca API
if (!signal) return { executed: false, reason: 'No valid entry signal (bars)' }; 

      const entryPrice = signal.lastClose; // entry price is the last close price from the signal (current price)
      const volatility = await alpaca.getVolatility(symbol); // implied volatility data from Alpaca means 
      const volatilityFactor = Math.min(volatility / 0.03, 1); // normalize volatility to a factor between 0 and 1

      // Calculate position size by checking account balance, entry price, stop loss, and volatility factor
      // commensurate with temperature
      const positionSize = require('./solarStrategy').getPositionSize(
        temp,
        this.accountBalance,
        entryPrice,
        stopLoss,
        volatilityFactor, 
        mood
      );

      // 
      const { takeProfit: tpPrice, stopLoss: slPrice } = getTPandSL( // get TP and SL prices based on entry price, side, and risk profile
        entryPrice,
        signal.side,
        takeProfit,
        stopLoss
      );

      await this.openTrade({ // open a trade with the Alpaca API
        symbol, // stock symbol
        side: signal.side, // long or short
        entryPrice, // entry price
        shares: positionSize, // number of shares to buy
        tpPrice, // take profit price (set with risk profile determined by lux)
        slPrice, // stop loss price (set with risk profile determined by lux)
        entryTime: Date.now(), // entry time in milliseconds
        maxHoldMinutes, // maximum holding time in minutes (set with risk profile determined by humidity)
        mood // mood of the day (set with solar sensor data at initial market open )
      });

      return { executed: true };
    } catch (error) {
      console.error(`‚ùå Error evaluating trade entry for ${symbol}:`, error.message);
      return { executed: false, reason: `Error: ${error.message}` };
    }
  }

  async getEntrySignal(symbol) {
    try {
      const bars = await alpaca.getPreviousBars(symbol, 5); // get the last 5 bars (candlestick data) for the chosen stock symbol

      if (!bars || bars.length < 2) {
        console.log(`‚ùå [${symbol}] Not enough bar data`);
        return null;
      }
      
      const closes = bars.map(b => b.close); // close prices
      // calculate trend and volume
      // Trend: Price difference between the last and first bar ‚Äî shows relative change / overall direction.
      const trend = closes[closes.length - 1] - closes[0];
      // Volume: Average volume of the last 5 bars ‚Äî shows market activity.
      // avgVolume: Average volume of the last 5 bars
      const avgVolume = bars.reduce((sum, b) => sum + (b.volume || 0), 0) / bars.length; // average volume over last 5 bars
      const lastVolume = bars[bars.length - 1]?.volume || 0; // most recent volume 

      // check if trend is significant, if not, fallback to random
      const minimalTrend = 0.005; // 0.5% change
      const trendUp = trend >= minimalTrend; // 0.5% increase
      const trendDown = trend <= -minimalTrend; // 0.5% decrease

      console.log(`üìä [${symbol}] Closes: ${closes.join(', ')}`); 
      console.log(`üìà Trend: ${trend.toFixed(4)} | Volume: ${lastVolume}/${avgVolume.toFixed(0)}`);

      // Enter Long
      if (trendUp) {
        console.log(`‚ö° Minimal uptrend detected. Enter LONG for ${symbol}`);
        return { side: 'long', lastClose: closes[closes.length - 1] };
      }
      // Enter Short
      if (trendDown) {
        console.log(`‚ö° Minimal downtrend detected. Enter SHORT for ${symbol}`);
        return { side: 'short', lastClose: closes[closes.length - 1] };
      }

      // Fallback Strategy: Randomly enter if no trend detected
      // This is a last resort to ensure some activity in the market
      const fallbackSide = Math.random() > 0.5 ? 'long' : 'short';
      console.log(`ü§∑ No trend. Randomly entering ${fallbackSide.toUpperCase()} for ${symbol}`);
      return { side: fallbackSide, lastClose: closes[closes.length - 1] };

      return null;
    } catch (error) {
      console.error(`‚ùå Error getting entry signal for ${symbol}:`, error.message);
      return null;
    }
  }

  // This method checks current price against TP & SL, checks max hold time ---> then  "updates" the open trades -> decides if the trade should be closed or not
  async updateOpenTrades() {
  
    // if there are no open trades, return early
    try {
    if (this.openTrades.length === 0) {
      return { updated: true, message: 'No open trades to update' };
    }
    
    const alpaca = require('./alpaca'); // Import Alpaca module 
    
    console.log(`üîÑ Updating ${this.openTrades.length} open trade(s)...`);
    
    // Loop through each open trade (last quote)
    // last quote = last price of the stock
    for (const trade of [...this.openTrades]) {
      const quote = await alpaca.getLastQuote(trade.symbol);
      if (!quote) {
        console.log(`‚ö†Ô∏è Could not get quote for ${trade.symbol}`);
        continue;
      }
      
      // Get the current price based on the trade side (long/short)
      // If the trade is long, use the bid price; if short, use the ask price
      const currentPrice = trade.side === 'long' ? quote.bidPrice : quote.askPrice;
      const holdTime = (Date.now() - trade.entryTime) / (1000 * 60); // minutes
      
      // Check for take profit
      if ((trade.side === 'long' && currentPrice >= trade.tpPrice) || 
          (trade.side === 'short' && currentPrice <= trade.tpPrice)) {
        console.log(`üéØ Take profit hit for ${trade.symbol} at ${currentPrice}`);
        await this.closeTrade(trade, currentPrice, 'take_profit');
        continue;
      }
      
      // Check for stop loss
      if ((trade.side === 'long' && currentPrice <= trade.slPrice) || 
          (trade.side === 'short' && currentPrice >= trade.slPrice)) {
        console.log(`üõë Stop loss hit for ${trade.symbol} at ${currentPrice}`);
        await this.closeTrade(trade, currentPrice, 'stop_loss');
        continue;
      }
      
      // Check for max hold time
      if (holdTime >= trade.maxHoldMinutes) {
        console.log(`‚è±Ô∏è Max hold time reached for ${trade.symbol}`);
        await this.closeTrade(trade, currentPrice, 'max_hold_time');
        continue;
      }
    }
    
    return { updated: true, message: `Updated ${this.openTrades.length} open trades` }; 
  } catch (error) {
    console.error('‚ùå Error updating open trades:', error.message);
    return { updated: false, error: error.message };
  }
}

// Close a trade (liquidate position = reverses the open trade) and log the details to Google Sheets
// This method is called when a trade reaches its take profit, stop loss, or max hold time
async closeTrade(trade, exitPrice, reason) {
  try {
    const alpaca = require('./alpaca'); // Import Alpaca module (same as above)
    
    // Execute the liquidation order on open trade
    const exitSide = trade.side === 'long' ? 'sell' : 'buy'; // if the trade is long (buy), sell to exit; if short (sell), buy to exit
    console.log(`üîÑ Executing liquidation order: ${exitSide.toUpperCase()} ${trade.shares} shares of ${trade.symbol}`);
    
    // // place the liquidation order to close the position
    try {
      const order = await alpaca.placeOrder(trade.symbol, trade.shares, exitSide);
      console.log(`‚úÖ Liquidation order placed successfully: ${order.id}`); // debug line for closed order
    } catch (orderError) {
      console.error(`‚ö†Ô∏è Error placing liquidation order: ${orderError.message}`); 
      // Continue with the function even if order fails, to maintain internal state
    } 

    // Calculate profit/loss
    const entryValue = trade.entryPrice * trade.shares; // entry value = entry price * number of shares
    const exitValue = exitPrice * trade.shares; // exit value = exit price * number of shares
    const pnl = trade.side === 'long'  // if the trade is long, profit/loss = exit value - entry value
      ? exitValue - entryValue 
      : entryValue - exitValue;
    
    const pnlPercent = (pnl / entryValue * 100).toFixed(2); // profit/loss percentage = (profit/loss / entry value) * 100
    
    console.log(`üíµ Closing ${trade.side} position in ${trade.symbol}:
      - Entry: $${trade.entryPrice} √ó ${trade.shares} shares
      - Exit: $${exitPrice}
      - P&L: $${pnl.toFixed(2)} (${pnlPercent}%)
      - Reason: ${reason}`);
    
    // Log the closed trade
    this.closedTrades.push({
      ...trade,
      exitPrice,
      exitTime: Date.now(),
      pnl,
      pnlPercent,
      reason
    });
    
    // Remove from open trades
    this.openTrades = this.openTrades.filter(t => t !== trade);
    
    // Log to Google sheets if you have that functionality
    const { logToSheet } = require('./logToSheets');
    const now = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
    
    await logToSheet([
      now,
      trade.symbol,
      trade.side,
      trade.entryPrice,
      exitPrice,
      trade.shares,
      // how much you made : (exit - entry price)
      pnl.toFixed(2), // P&L in dollars
      pnlPercent, // P&L percentage, profit/loss 
      reason,
      (trade.exitTime - trade.entryTime) / (1000 * 60) // Hold time in minutes
    ], 'Alpaca Trades');
    
    return { closed: true }; 
  } catch (error) {
    console.error(`‚ùå Error closing trade for ${trade.symbol}:`, error.message);
    return { closed: false, error: error.message };
  }
}

// forceCloseAll method to close all open trades at the end of the day (market close)
// This method is called when the market closes or when a force close is triggered
async forceCloseAll() {
  try {
    if (this.openTrades.length === 0) {
      console.log('üì≠ No open trades to close');
      return { closed: true, message: 'No open trades to close' };
    }
    
    console.log(`üö® Force closing ${this.openTrades.length} open trade(s)...`);
    
    const alpaca = require('./alpaca');
    
    // Loop through each open trade and close it
    for (const trade of [...this.openTrades]) {
      const quote = await alpaca.getLastQuote(trade.symbol);
      if (!quote) continue;
      
      const currentPrice = trade.side === 'long' ? quote.bidPrice : quote.askPrice; // get the current price based on the trade side
      await this.closeTrade(trade, currentPrice, 'market_close'); // close the trade at market close
    }
    
    return { closed: true, message: 'All trades closed' };
  } catch (error) {
    console.error('‚ùå Error force closing all trades:', error.message);
    return { closed: false, error: error.message };
  }
}
  
// Add this method to TradeManager class in tradeManager.js
async openTrade(tradeConfig) {
  try {
    const { symbol, side, entryPrice, shares, tpPrice, slPrice, entryTime, maxHoldMinutes, mood } = tradeConfig;
    
    // Execute the trade via Alpaca
    const orderSide = side === 'long' ? 'buy' : 'sell';
    const order = await alpaca.placeOrder(symbol, shares, orderSide);
    
    if (!order) {
      throw new Error(`Failed to place ${orderSide} order for ${symbol}`);
    }
    
    // Record the trade
    const tradeRecord = {
      symbol,
      side,
      entryPrice,
      shares,
      tpPrice,
      slPrice,
      entryTime,
      maxHoldMinutes,
      mood,
      orderId: order.id
    };
    
    this.openTrades.push(tradeRecord);
    
    // Log to Google Sheets
    const now = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
    await logToSheet([
      now,
      symbol,
      side,
      entryPrice,
      'OPEN',
      shares,
      '0',
      '0%',
      'ENTRY',
      '0'
    ], TRADE_LOG_SHEET);
    
    console.log(`üõí Opened ${side} position in ${symbol}:
      - Price: $${entryPrice}
      - Shares: ${shares}
      - Take Profit: $${tpPrice}
      - Stop Loss: $${slPrice}
      - Max Hold: ${maxHoldMinutes} minutes`);
    
    return { success: true, trade: tradeRecord };
  } catch (error) {
    console.error(`‚ùå Error opening trade for ${tradeConfig.symbol}:`, error.message);
    return { success: false, error: error.message };
  }
}

}

module.exports = TradeManager;